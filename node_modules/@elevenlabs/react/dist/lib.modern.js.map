{"version":3,"file":"lib.modern.js","sources":["../src/scribe.ts","../src/index.ts","../src/version.ts"],"sourcesContent":["import { useEffect, useRef, useState, useCallback } from \"react\";\nimport { Scribe, RealtimeEvents } from \"@elevenlabs/client\";\nimport type {\n  RealtimeConnection,\n  AudioOptions,\n  MicrophoneOptions,\n  AudioFormat,\n  CommitStrategy,\n  PartialTranscriptMessage,\n  CommittedTranscriptMessage,\n  CommittedTranscriptWithTimestampsMessage,\n  ScribeErrorMessage,\n  ScribeAuthErrorMessage,\n  ScribeQuotaExceededErrorMessage,\n} from \"@elevenlabs/client\";\n\n// ============= Types =============\n\nexport type ScribeStatus =\n  | \"disconnected\"\n  | \"connecting\"\n  | \"connected\"\n  | \"transcribing\"\n  | \"error\";\n\nexport interface TranscriptSegment {\n  id: string;\n  text: string;\n  timestamp: number;\n  isFinal: boolean;\n}\n\nexport interface ScribeCallbacks {\n  onSessionStarted?: () => void;\n  onPartialTranscript?: (data: { text: string }) => void;\n  onCommittedTranscript?: (data: { text: string }) => void;\n  onCommittedTranscriptWithTimestamps?: (data: {\n    text: string;\n    timestamps?: { start: number; end: number }[];\n  }) => void;\n  onError?: (error: Error | Event) => void;\n  onAuthError?: (data: { error: string }) => void;\n  onQuotaExceededError?: (data: { error: string }) => void;\n  onConnect?: () => void;\n  onDisconnect?: () => void;\n}\n\nexport interface ScribeHookOptions extends ScribeCallbacks {\n  // Connection options\n  token?: string;\n  modelId?: string;\n  baseUri?: string;\n\n  // VAD options\n  commitStrategy?: CommitStrategy;\n  vadSilenceThresholdSecs?: number;\n  vadThreshold?: number;\n  minSpeechDurationMs?: number;\n  minSilenceDurationMs?: number;\n  languageCode?: string;\n\n  // Microphone options (for automatic microphone mode)\n  microphone?: {\n    deviceId?: string;\n    echoCancellation?: boolean;\n    noiseSuppression?: boolean;\n    autoGainControl?: boolean;\n    channelCount?: number;\n  };\n\n  // Manual audio options\n  audioFormat?: AudioFormat;\n  sampleRate?: number;\n\n  // Auto-connect on mount\n  autoConnect?: boolean;\n\n  // Include timestamps\n  includeTimestamps?: boolean;\n}\n\nexport interface UseScribeReturn {\n  // State\n  status: ScribeStatus;\n  isConnected: boolean;\n  isTranscribing: boolean;\n  partialTranscript: string;\n  committedTranscripts: TranscriptSegment[];\n  error: string | null;\n\n  // Connection methods\n  connect: (options?: Partial<ScribeHookOptions>) => Promise<void>;\n  disconnect: () => void;\n\n  // Audio methods (for manual mode)\n  sendAudio: (\n    audioBase64: string,\n    options?: { commit?: boolean; sampleRate?: number }\n  ) => void;\n  commit: () => void;\n\n  // Utility methods\n  clearTranscripts: () => void;\n  getConnection: () => RealtimeConnection | null;\n}\n\n// ============= Hook Implementation =============\n\nexport function useScribe(options: ScribeHookOptions = {}): UseScribeReturn {\n  const {\n    // Callbacks\n    onSessionStarted,\n    onPartialTranscript,\n    onCommittedTranscript,\n    onCommittedTranscriptWithTimestamps,\n    onError,\n    onAuthError,\n    onConnect,\n    onDisconnect,\n    onQuotaExceededError,\n\n    // Connection options\n    token: defaultToken,\n    modelId: defaultModelId,\n    baseUri: defaultBaseUri,\n    commitStrategy: defaultCommitStrategy,\n    vadSilenceThresholdSecs: defaultVadSilenceThresholdSecs,\n    vadThreshold: defaultVadThreshold,\n    minSpeechDurationMs: defaultMinSpeechDurationMs,\n    minSilenceDurationMs: defaultMinSilenceDurationMs,\n    languageCode: defaultLanguageCode,\n\n    // Mode options\n    microphone: defaultMicrophone,\n    audioFormat: defaultAudioFormat,\n    sampleRate: defaultSampleRate,\n\n    // Auto-connect\n    autoConnect = false,\n  } = options;\n\n  const connectionRef = useRef<RealtimeConnection | null>(null);\n\n  const [status, setStatus] = useState<ScribeStatus>(\"disconnected\");\n  const [partialTranscript, setPartialTranscript] = useState<string>(\"\");\n  const [committedTranscripts, setCommittedTranscripts] = useState<\n    TranscriptSegment[]\n  >([]);\n  const [error, setError] = useState<string | null>(null);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      connectionRef.current?.close();\n    };\n  }, []);\n\n  const connect = useCallback(\n    async (runtimeOptions: Partial<ScribeHookOptions> = {}) => {\n      if (connectionRef.current) {\n        console.warn(\"Already connected\");\n        return;\n      }\n\n      try {\n        setStatus(\"connecting\");\n        setError(null);\n\n        // Merge default options with runtime options\n        const token = runtimeOptions.token || defaultToken;\n        const modelId = runtimeOptions.modelId || defaultModelId;\n\n        if (!token) {\n          throw new Error(\"Token is required\");\n        }\n        if (!modelId) {\n          throw new Error(\"Model ID is required\");\n        }\n\n        // Determine mode: microphone or manual\n        const microphone = runtimeOptions.microphone || defaultMicrophone;\n        const audioFormat = runtimeOptions.audioFormat || defaultAudioFormat;\n        const sampleRate = runtimeOptions.sampleRate || defaultSampleRate;\n\n        let connection: RealtimeConnection;\n\n        // Determine if timestamps should be included based on whether the callback was provided\n        // We do this instead of providing includeTimestamps as we can assume that if the callback is provided, the user wants timestamps\n        const includeTimestamps = !!(\n          runtimeOptions.onCommittedTranscriptWithTimestamps ||\n          onCommittedTranscriptWithTimestamps\n        );\n\n        if (microphone) {\n          // Microphone mode\n          connection = Scribe.connect({\n            token,\n            modelId,\n            baseUri: runtimeOptions.baseUri || defaultBaseUri,\n            commitStrategy:\n              runtimeOptions.commitStrategy || defaultCommitStrategy,\n            vadSilenceThresholdSecs:\n              runtimeOptions.vadSilenceThresholdSecs ||\n              defaultVadSilenceThresholdSecs,\n            vadThreshold: runtimeOptions.vadThreshold || defaultVadThreshold,\n            minSpeechDurationMs:\n              runtimeOptions.minSpeechDurationMs || defaultMinSpeechDurationMs,\n            minSilenceDurationMs:\n              runtimeOptions.minSilenceDurationMs ||\n              defaultMinSilenceDurationMs,\n            languageCode: runtimeOptions.languageCode || defaultLanguageCode,\n            microphone,\n            includeTimestamps,\n          } as MicrophoneOptions);\n        } else if (audioFormat && sampleRate) {\n          // Manual audio mode\n          connection = Scribe.connect({\n            token,\n            modelId,\n            baseUri: runtimeOptions.baseUri || defaultBaseUri,\n            commitStrategy:\n              runtimeOptions.commitStrategy || defaultCommitStrategy,\n            vadSilenceThresholdSecs:\n              runtimeOptions.vadSilenceThresholdSecs ||\n              defaultVadSilenceThresholdSecs,\n            vadThreshold: runtimeOptions.vadThreshold || defaultVadThreshold,\n            minSpeechDurationMs:\n              runtimeOptions.minSpeechDurationMs || defaultMinSpeechDurationMs,\n            minSilenceDurationMs:\n              runtimeOptions.minSilenceDurationMs ||\n              defaultMinSilenceDurationMs,\n            languageCode: runtimeOptions.languageCode || defaultLanguageCode,\n            includeTimestamps,\n            audioFormat,\n            sampleRate,\n          } as AudioOptions);\n        } else {\n          throw new Error(\n            \"Either microphone options or (audioFormat + sampleRate) must be provided\"\n          );\n        }\n\n        connectionRef.current = connection;\n\n        // Set up event listeners\n        connection.on(RealtimeEvents.SESSION_STARTED, () => {\n          setStatus(\"connected\");\n          onSessionStarted?.();\n        });\n\n        connection.on(RealtimeEvents.PARTIAL_TRANSCRIPT, (data: unknown) => {\n          const message = data as PartialTranscriptMessage;\n          setPartialTranscript(message.text);\n          setStatus(\"transcribing\");\n          onPartialTranscript?.(message);\n        });\n\n        connection.on(RealtimeEvents.COMMITTED_TRANSCRIPT, (data: unknown) => {\n          const message = data as CommittedTranscriptMessage;\n          const segment: TranscriptSegment = {\n            id: `${Date.now()}-${Math.random()}`,\n            text: message.text,\n            timestamp: Date.now(),\n            isFinal: true,\n          };\n          setCommittedTranscripts(prev => [...prev, segment]);\n          setPartialTranscript(\"\");\n          onCommittedTranscript?.(message);\n        });\n\n        connection.on(\n          RealtimeEvents.COMMITTED_TRANSCRIPT_WITH_TIMESTAMPS,\n          (data: unknown) => {\n            const message = data as CommittedTranscriptWithTimestampsMessage;\n            const segment: TranscriptSegment = {\n              id: `${Date.now()}-${Math.random()}`,\n              text: message.text,\n              timestamp: Date.now(),\n              isFinal: true,\n            };\n            setCommittedTranscripts(prev => [...prev, segment]);\n            setPartialTranscript(\"\");\n            onCommittedTranscriptWithTimestamps?.(message);\n          }\n        );\n\n        connection.on(RealtimeEvents.ERROR, (err: unknown) => {\n          const message = err as ScribeErrorMessage;\n          setError(message.error);\n          setStatus(\"error\");\n          onError?.(new Error(message.error));\n        });\n\n        connection.on(RealtimeEvents.AUTH_ERROR, (data: unknown) => {\n          const message = data as ScribeAuthErrorMessage;\n          setError(message.error);\n          setStatus(\"error\");\n          onAuthError?.(message);\n        });\n\n        connection.on(RealtimeEvents.QUOTA_EXCEEDED, (data: unknown) => {\n          const message = data as ScribeQuotaExceededErrorMessage;\n          setError(message.error);\n          setStatus(\"error\");\n          onQuotaExceededError?.(message);\n        });\n\n        connection.on(RealtimeEvents.OPEN, () => {\n          onConnect?.();\n        });\n\n        connection.on(RealtimeEvents.CLOSE, () => {\n          setStatus(\"disconnected\");\n          connectionRef.current = null;\n          onDisconnect?.();\n        });\n      } catch (err) {\n        const errorMessage =\n          err instanceof Error ? err.message : \"Failed to connect\";\n        setError(errorMessage);\n        setStatus(\"error\");\n        throw err;\n      }\n    },\n    [\n      defaultToken,\n      defaultModelId,\n      defaultBaseUri,\n      defaultCommitStrategy,\n      defaultVadSilenceThresholdSecs,\n      defaultVadThreshold,\n      defaultMinSpeechDurationMs,\n      defaultMinSilenceDurationMs,\n      defaultLanguageCode,\n      defaultMicrophone,\n      defaultAudioFormat,\n      defaultSampleRate,\n      onSessionStarted,\n      onPartialTranscript,\n      onCommittedTranscript,\n      onCommittedTranscriptWithTimestamps,\n      onError,\n      onAuthError,\n      onConnect,\n      onDisconnect,\n      onQuotaExceededError,\n    ]\n  );\n\n  const disconnect = useCallback(() => {\n    connectionRef.current?.close();\n    connectionRef.current = null;\n    setStatus(\"disconnected\");\n  }, []);\n\n  const sendAudio = useCallback(\n    (\n      audioBase64: string,\n      options?: { commit?: boolean; sampleRate?: number }\n    ) => {\n      if (!connectionRef.current) {\n        throw new Error(\"Not connected to Scribe\");\n      }\n      connectionRef.current.send({ audioBase64, ...options });\n    },\n    []\n  );\n\n  const commit = useCallback(() => {\n    if (!connectionRef.current) {\n      throw new Error(\"Not connected to Scribe\");\n    }\n    connectionRef.current.commit();\n  }, []);\n\n  const clearTranscripts = useCallback(() => {\n    setCommittedTranscripts([]);\n    setPartialTranscript(\"\");\n  }, []);\n\n  const getConnection = useCallback(() => {\n    return connectionRef.current;\n  }, []);\n\n  // Auto-connect if enabled\n  useEffect(() => {\n    if (autoConnect) {\n      connect();\n    }\n  }, [autoConnect, connect]);\n\n  return {\n    // State\n    status,\n    isConnected: status === \"connected\" || status === \"transcribing\",\n    isTranscribing: status === \"transcribing\",\n    partialTranscript,\n    committedTranscripts,\n    error,\n\n    // Methods\n    connect,\n    disconnect,\n    sendAudio,\n    commit,\n    clearTranscripts,\n    getConnection,\n  };\n}\n\n// Export types and enums from client for convenience\nexport {\n  AudioFormat,\n  CommitStrategy,\n  RealtimeEvents,\n} from \"@elevenlabs/client\";\nexport type { RealtimeConnection } from \"@elevenlabs/client\";\n","import { useEffect, useRef, useState } from \"react\";\nimport {\n  Conversation,\n  type SessionConfig,\n  type Options,\n  type ClientToolsConfig,\n  type InputConfig,\n  type AudioWorkletConfig,\n  type OutputConfig,\n  type FormatConfig,\n  type Mode,\n  type Status,\n  type Callbacks,\n} from \"@elevenlabs/client\";\n\n// Device configuration types for audio device switching\nexport type DeviceFormatConfig = {\n  format: \"pcm\" | \"ulaw\";\n  sampleRate: number;\n  outputDeviceId?: string;\n};\n\nexport type DeviceInputConfig = {\n  preferHeadphonesForIosDevices?: boolean;\n  inputDeviceId?: string;\n};\n\nimport { PACKAGE_VERSION } from \"./version\";\n\nexport type Location = \"us\" | \"global\" | \"eu-residency\" | \"in-residency\";\n\nexport function parseLocation(location: string = \"us\"): Location {\n  switch (location) {\n    case \"eu-residency\":\n    case \"in-residency\":\n    case \"us\":\n    case \"global\":\n      return location;\n    default:\n      console.warn(\n        `[ConversationalAI] Invalid server-location: ${location}. Defaulting to \"us\"`\n      );\n      return \"us\";\n  }\n}\n\nexport function getOriginForLocation(location: Location): string {\n  const originMap: Record<Location, string> = {\n    us: \"wss://api.elevenlabs.io\",\n    \"eu-residency\": \"wss://api.eu.residency.elevenlabs.io\",\n    \"in-residency\": \"wss://api.in.residency.elevenlabs.io\",\n    global: \"wss://api.elevenlabs.io\",\n  };\n\n  return originMap[location];\n}\n\nexport function getLivekitUrlForLocation(location: Location): string {\n  const livekitUrlMap: Record<Location, string> = {\n    us: \"wss://livekit.rtc.elevenlabs.io\",\n    \"eu-residency\": \"wss://livekit.rtc.eu.residency.elevenlabs.io\",\n    \"in-residency\": \"wss://livekit.rtc.in.residency.elevenlabs.io\",\n    global: \"wss://livekit.rtc.elevenlabs.io\",\n  };\n\n  return livekitUrlMap[location];\n}\n\nexport type {\n  Role,\n  Mode,\n  Status,\n  SessionConfig,\n  DisconnectionDetails,\n  Language,\n  VadScoreEvent,\n  InputConfig,\n  FormatConfig,\n  VoiceConversation,\n  TextConversation,\n  Callbacks,\n} from \"@elevenlabs/client\";\nexport { postOverallFeedback } from \"@elevenlabs/client\";\n\n// Scribe exports\nexport {\n  useScribe,\n  AudioFormat,\n  CommitStrategy,\n  RealtimeEvents,\n} from \"./scribe\";\nexport type {\n  ScribeStatus,\n  TranscriptSegment,\n  ScribeCallbacks,\n  ScribeHookOptions,\n  UseScribeReturn,\n  RealtimeConnection,\n} from \"./scribe\";\n\nexport type HookOptions = Partial<\n  SessionConfig &\n    HookCallbacks &\n    ClientToolsConfig &\n    InputConfig &\n    OutputConfig &\n    AudioWorkletConfig &\n    FormatConfig & {\n      serverLocation?: Location | string;\n    }\n>;\nexport type ControlledState = {\n  micMuted?: boolean;\n  volume?: number;\n};\nexport type HookCallbacks = Pick<\n  Callbacks,\n  | \"onConnect\"\n  | \"onDisconnect\"\n  | \"onError\"\n  | \"onMessage\"\n  | \"onAudio\"\n  | \"onModeChange\"\n  | \"onStatusChange\"\n  | \"onCanSendFeedbackChange\"\n  | \"onDebug\"\n  | \"onUnhandledClientToolCall\"\n  | \"onVadScore\"\n  | \"onInterruption\"\n  | \"onAgentToolResponse\"\n  | \"onConversationMetadata\"\n  | \"onMCPToolCall\"\n  | \"onMCPConnectionStatus\"\n  | \"onAsrInitiationMetadata\"\n  | \"onAgentChatResponsePart\"\n>;\n\nexport function useConversation<T extends HookOptions & ControlledState>(\n  props: T = {} as T\n) {\n  const { micMuted, volume, serverLocation, ...defaultOptions } = props;\n  const conversationRef = useRef<Conversation | null>(null);\n  const lockRef = useRef<Promise<Conversation> | null>(null);\n  const [status, setStatus] = useState<Status>(\"disconnected\");\n  const [canSendFeedback, setCanSendFeedback] = useState(false);\n  const [mode, setMode] = useState<Mode>(\"listening\");\n\n  const micMutedRef = useRef<boolean | undefined>(micMuted);\n  const volumeRef = useRef<number | undefined>(volume);\n\n  micMutedRef.current = micMuted;\n  volumeRef.current = volume;\n\n  useEffect(() => {\n    if (micMuted !== undefined) {\n      conversationRef?.current?.setMicMuted(micMuted);\n    }\n  }, [micMuted]);\n\n  useEffect(() => {\n    if (volume !== undefined) {\n      conversationRef?.current?.setVolume({ volume });\n    }\n  }, [volume]);\n\n  useEffect(() => {\n    return () => {\n      conversationRef.current?.endSession();\n    };\n  }, []);\n\n  return {\n    startSession: (async (options?: HookOptions) => {\n      if (conversationRef.current?.isOpen()) {\n        return conversationRef.current.getId();\n      }\n\n      if (lockRef.current) {\n        const conversation = await lockRef.current;\n        return conversation.getId();\n      }\n\n      try {\n        const resolvedServerLocation = parseLocation(\n          options?.serverLocation || serverLocation\n        );\n        const origin = getOriginForLocation(resolvedServerLocation);\n        const livekitUrl = getLivekitUrlForLocation(resolvedServerLocation);\n\n        lockRef.current = Conversation.startSession({\n          ...(defaultOptions ?? {}),\n          ...(options ?? {}),\n          origin,\n          livekitUrl,\n          overrides: {\n            ...(defaultOptions?.overrides ?? {}),\n            ...(options?.overrides ?? {}),\n            client: {\n              ...(defaultOptions?.overrides?.client ?? {}),\n              ...(options?.overrides?.client ?? {}),\n              source:\n                options?.overrides?.client?.source ||\n                defaultOptions?.overrides?.client?.source ||\n                \"react_sdk\",\n              version:\n                options?.overrides?.client?.version ||\n                defaultOptions?.overrides?.client?.version ||\n                PACKAGE_VERSION,\n            },\n          },\n          // Pass through user-provided callbacks\n          onConnect: options?.onConnect || defaultOptions?.onConnect,\n          onDisconnect: options?.onDisconnect || defaultOptions?.onDisconnect,\n          onError: options?.onError || defaultOptions?.onError,\n          onMessage: options?.onMessage || defaultOptions?.onMessage,\n          onAudio: options?.onAudio || defaultOptions?.onAudio,\n          onDebug: options?.onDebug || defaultOptions?.onDebug,\n          onUnhandledClientToolCall:\n            options?.onUnhandledClientToolCall ||\n            defaultOptions?.onUnhandledClientToolCall,\n          onVadScore: options?.onVadScore || defaultOptions?.onVadScore,\n          onInterruption:\n            options?.onInterruption || defaultOptions?.onInterruption,\n          onAgentToolResponse:\n            options?.onAgentToolResponse || defaultOptions?.onAgentToolResponse,\n          onConversationMetadata:\n            options?.onConversationMetadata ||\n            defaultOptions?.onConversationMetadata,\n          onMCPToolCall:\n            options?.onMCPToolCall || defaultOptions?.onMCPToolCall,\n          onMCPConnectionStatus:\n            options?.onMCPConnectionStatus ||\n            defaultOptions?.onMCPConnectionStatus,\n          onAsrInitiationMetadata:\n            options?.onAsrInitiationMetadata ||\n            defaultOptions?.onAsrInitiationMetadata,\n          onAgentChatResponsePart:\n            options?.onAgentChatResponsePart ||\n            defaultOptions?.onAgentChatResponsePart,\n          onModeChange: ({ mode }) => {\n            setMode(mode);\n            (options?.onModeChange || defaultOptions?.onModeChange)?.({ mode });\n          },\n          onStatusChange: ({ status }) => {\n            setStatus(status);\n            (options?.onStatusChange || defaultOptions?.onStatusChange)?.({\n              status,\n            });\n          },\n          onCanSendFeedbackChange: ({ canSendFeedback }) => {\n            setCanSendFeedback(canSendFeedback);\n            (\n              options?.onCanSendFeedbackChange ||\n              defaultOptions?.onCanSendFeedbackChange\n            )?.({ canSendFeedback });\n          },\n        } as Options);\n\n        conversationRef.current = await lockRef.current;\n        // Persist controlled state between sessions using refs to get current values\n        if (micMutedRef.current !== undefined) {\n          conversationRef.current.setMicMuted(micMutedRef.current);\n        }\n        if (volumeRef.current !== undefined) {\n          conversationRef.current.setVolume({ volume: volumeRef.current });\n        }\n\n        return conversationRef.current.getId();\n      } finally {\n        lockRef.current = null;\n      }\n    }) as T extends SessionConfig\n      ? (options?: HookOptions) => Promise<string>\n      : (options: SessionConfig & HookOptions) => Promise<string>,\n    endSession: async () => {\n      const conversation = conversationRef.current;\n      conversationRef.current = null;\n      await conversation?.endSession();\n    },\n    setVolume: ({ volume }: { volume: number }) => {\n      conversationRef.current?.setVolume({ volume });\n    },\n    getInputByteFrequencyData: () => {\n      return conversationRef.current?.getInputByteFrequencyData();\n    },\n    getOutputByteFrequencyData: () => {\n      return conversationRef.current?.getOutputByteFrequencyData();\n    },\n    getInputVolume: () => {\n      return conversationRef.current?.getInputVolume() ?? 0;\n    },\n    getOutputVolume: () => {\n      return conversationRef.current?.getOutputVolume() ?? 0;\n    },\n    sendFeedback: (like: boolean) => {\n      conversationRef.current?.sendFeedback(like);\n    },\n    getId: () => {\n      return conversationRef.current?.getId();\n    },\n    sendContextualUpdate: (text: string) => {\n      conversationRef.current?.sendContextualUpdate(text);\n    },\n    sendUserMessage: (text: string) => {\n      conversationRef.current?.sendUserMessage(text);\n    },\n    sendUserActivity: () => {\n      conversationRef.current?.sendUserActivity();\n    },\n    sendMCPToolApprovalResult: (toolCallId: string, isApproved: boolean) => {\n      conversationRef.current?.sendMCPToolApprovalResult(\n        toolCallId,\n        isApproved\n      );\n    },\n    changeInputDevice: async (\n      config: DeviceFormatConfig & DeviceInputConfig\n    ) => {\n      if (\n        conversationRef.current &&\n        \"changeInputDevice\" in conversationRef.current\n      ) {\n        return await (\n          conversationRef.current as unknown as {\n            changeInputDevice: (config: any) => Promise<any>;\n          }\n        ).changeInputDevice(config);\n      }\n      throw new Error(\n        \"Device switching is only available for voice conversations\"\n      );\n    },\n    changeOutputDevice: async (config: DeviceFormatConfig) => {\n      if (\n        conversationRef.current &&\n        \"changeOutputDevice\" in conversationRef.current\n      ) {\n        return await (\n          conversationRef.current as unknown as {\n            changeOutputDevice: (config: any) => Promise<any>;\n          }\n        ).changeOutputDevice(config);\n      }\n      throw new Error(\n        \"Device switching is only available for voice conversations\"\n      );\n    },\n    status,\n    canSendFeedback,\n    micMuted,\n    isSpeaking: mode === \"speaking\",\n  };\n}\n\n// const con = useConversation({agentId: \"\"})\n","// This file is auto-generated during build\nexport const PACKAGE_VERSION = \"0.11.0\";\n"],"names":["useScribe","options","onSessionStarted","onPartialTranscript","onCommittedTranscript","onCommittedTranscriptWithTimestamps","onError","onAuthError","onConnect","onDisconnect","onQuotaExceededError","token","defaultToken","modelId","defaultModelId","baseUri","defaultBaseUri","commitStrategy","defaultCommitStrategy","vadSilenceThresholdSecs","defaultVadSilenceThresholdSecs","vadThreshold","defaultVadThreshold","minSpeechDurationMs","defaultMinSpeechDurationMs","minSilenceDurationMs","defaultMinSilenceDurationMs","languageCode","defaultLanguageCode","microphone","defaultMicrophone","audioFormat","defaultAudioFormat","sampleRate","defaultSampleRate","autoConnect","connectionRef","useRef","status","setStatus","useState","partialTranscript","setPartialTranscript","committedTranscripts","setCommittedTranscripts","error","setError","useEffect","_connectionRef$curren","current","close","connect","useCallback","async","runtimeOptions","console","warn","Error","connection","includeTimestamps","Scribe","on","RealtimeEvents","SESSION_STARTED","PARTIAL_TRANSCRIPT","data","message","text","COMMITTED_TRANSCRIPT","segment","id","Date","now","Math","random","timestamp","isFinal","prev","COMMITTED_TRANSCRIPT_WITH_TIMESTAMPS","ERROR","err","AUTH_ERROR","QUOTA_EXCEEDED","OPEN","CLOSE","errorMessage","disconnect","_connectionRef$curren2","sendAudio","audioBase64","send","_extends","commit","clearTranscripts","getConnection","isConnected","isTranscribing","_excluded","parseLocation","location","getOriginForLocation","us","global","getLivekitUrlForLocation","useConversation","props","micMuted","volume","serverLocation","defaultOptions","_objectWithoutPropertiesLoose","conversationRef","lockRef","canSendFeedback","setCanSendFeedback","mode","setMode","micMutedRef","volumeRef","_conversationRef$curr","undefined","setMicMuted","_conversationRef$curr2","setVolume","_conversationRef$curr3","endSession","startSession","_conversationRef$curr4","isOpen","getId","_defaultOptions$overr","_options$overrides","_defaultOptions$overr2","_defaultOptions$overr3","_options$overrides$cl","_options$overrides2","_options$overrides3","_defaultOptions$overr4","_options$overrides4","_defaultOptions$overr5","resolvedServerLocation","origin","livekitUrl","Conversation","overrides","client","source","version","onMessage","onAudio","onDebug","onUnhandledClientToolCall","onVadScore","onInterruption","onAgentToolResponse","onConversationMetadata","onMCPToolCall","onMCPConnectionStatus","onAsrInitiationMetadata","onAgentChatResponsePart","onModeChange","_ref","onStatusChange","_ref2","onCanSendFeedbackChange","_ref3","conversation","_conversationRef$curr5","getInputByteFrequencyData","_conversationRef$curr6","getOutputByteFrequencyData","_conversationRef$curr7","getInputVolume","_conversationRef$curr8","_conversationRef$curr9","getOutputVolume","_conversationRef$curr0","_conversationRef$curr1","sendFeedback","like","_conversationRef$curr10","_conversationRef$curr11","sendContextualUpdate","_conversationRef$curr12","sendUserMessage","_conversationRef$curr13","sendUserActivity","_conversationRef$curr14","sendMCPToolApprovalResult","toolCallId","isApproved","_conversationRef$curr15","changeInputDevice","config","changeOutputDevice","isSpeaking"],"mappings":"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"}